\documentclass[a4paper]{report}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Change Detection for Digital Art}
\author{Joseph Allen}

\begin{document}
\maketitle

\begin{abstract}
In Computer Science we are used to collaboration, it is a fundamental aspect of programming careers to apply technical skills with a real world problem to create a useful application or system. Art and Computer Science are almost as far apart as possible, where Art strives to create arguably meaningless products with no use or application other than to convey or elicit emotion. 

The outcome of this project will be the creation of a product which will allow artists to trivially perform basic change detection with the sole purpose of artistic play. This project will help introduce non-technical artists to programming, inspire a sense of curiosity to delve deeper into the code, and hopefully transition them into mastery of a language.

I started out with a practical focus of creating an algorithm with high accuracy and implementing powerful architecture, but through interviews discovered that artists would rather have a digital playground over high accuracy.

My goal here is to create a project the encourages Artists to be more like Computer Scientist, and vice-versa.
\end{abstract}

\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
Thanks to my Family for carrying me, Georgina for holding my hand, and my friends for making me smile.


Thank you for Tim Morris for all your support and guidance throughout this project.
\end{abstract}

\tableofcontents
\clearpage

\chapter{Introduction}
\section{The Current Problem}
This Project is split into two separate problems. First we have the Image Processing problem of change detection in live video. Second we have the software engineering problem of creating a product for an artist.

In Image Processing change detection is the process of splitting an image up into two separate masks:
\begin{enumerate}
  \item The foreground mask, one consisting of objects that are considered to be a change of interest such as objects,shadows and reflections.
  \item The background mask , consisting of the unchanged or unimportant environment of the scene, this mask can be simply considered the NOT of the foreground mask.
\end{enumerate}

The other problem lies in creating a usable product for my client, an artist. In this there are problems of over-ambitious goals and requirement changes. While I started the project focusing on the accuracy of my change detection, over time I came to realise that artists do not care about the robustness of the change detection, they care more about the visuals and ease of use of the system with a very experimental way of thinking.

\section{Proposed Solution}
I propose creation of a digital playground in the Processing\cite{PROCESSING} IDE, in a form that is easy to use and install for both technical and non-technical artists. I wish to create a product which will give non-technical artists an introduction to Processing, and at the same time other aspects of programming to guide them to curiosity and then mastery of my tool as well as the Java Programming language. The plan was originally to implement the SAKBOT architecture\cite{SAKBOT}, however I later discovered that this advantageous architecture did not serve the purpose of this project.

\section{What is Processing?}
Processing is, by their own definition, "a flexible software sketchbook and a language for learning how to code within the context of the visual arts."\cite{PROCESSING}. Processing is open source and exists to give artists a simple introduction to using programming to create digital art. I took this project as a source of inspiration for my own, deciding to build my project in Processing and also follow their ethos of inspiring and teaching artists to be more comfortable with digital art and programming.

Daniel Shiffman \cite{SHIFFMAN} is a project lead at the Processing foundation, and he creates some very impressive video tutorials to help get artist started with programming and their use of Processing, I am inspired to do the same and create video tutorials on how to use my project to help overcome the difficulties associated with Processing setup and setting up the project itself.

\section{How do we currently do things?}
Collaboration is a common technique to merge two different creative fields together to create something relevant to both fields. This collaboration can occur between two artists but also between two completely unrelated fields to create something meaningful. 

An example I discovered while researching with my client was from a show called Sk-interfaces \cite{SKIN}. We met the scientist who created the living skin coat and the piece itself provoked controversial discussions about whether or not the coat itself was "alive". When the exhibit came to its end the artist felt too attached to the project and believed in turning off she was killing a living thing. It is interesting to reflect on this dichotomy between an artistic and emotional approach in contrast to the cold and functional approach of the scientist.

\section{Aims}
By the end of this project I hope to have created a product which will help artists introduce themselves to code, inspire a curiosity to do more, and give a tool that leads to mastery in a similar way to Processing\cite{PROCESSING} does itself.

\section{Methodology}
The Project started out with a Cowboy Coding approach where each week was a spike to see what was possible and help understand the possibilities, in a way fitting the "Trial and Error" approach that artists take, the main focus of this early stage was to gain a more in depth understanding of the trade-offs between frame-rate and increased accuracy of the change detection itself.

The second half of the project pivoted to a more structured approach, I now knew what functionality was possible and I used a Kanban\cite{KANBAN} approach since there is only one developer working on this project(myself) and this gave me much needed visualization of the tasks that needed to be completed to make the project a success. This period was one of focusing on Usability and the clients needs over what I ,as a computer scientist, deemed important. I elicited the requirements necessary here through a semi-structured focus group and a structured questionnaire which I sent to relevant artists.

\chapter{Apprehension}
\section{Conception}
The thought of somehow creating Digital Art came to me whilst working in my year in industry at a web development agency, I found that the work was intense, but there were long periods of inactivity. In these periods of inactivity I tried to find more personal use of the web language CSS, normally used to style web pages. I focused heavily on using built in transitions to make interesting animations which I later applied to my job in client-work. I made a goal to try to create a CSS only art gallery and went on to give a talk at my job about CSS-only artwork. To understand more about the art world I talked to my good friend Sarah.

\subsection{Sarah (Client)}
Sarah is a third year Interactive Art student at the Manchester Metropolitan University. At the time her work was focused heavily on creating Algorithms which generate art??? She spent a lot more time researching programming for Digital Art and introduced me to Processing \cite{PROCESSING}. I would also occasionally try to help her with what she was working on by creating quick and short code demos, from here I realized that programming for an artist would be an interesting topic for my third year project. My main concern was that the over-ambitious and experimental work of an artist would clash with a long-term project that Computer Science anticipates. My goal then became to try to offer something generic for artists that would utilize Image Processing. 

\subsection{Processing as inspiration}
After my introduction to Processing I decided to try to find a simple list of challenges to hone my skills, what I discovered was that such a list did not exist(or perhaps I was looking in the wrong place). I decided instead to host my own challenges and create an opportunity for others where there was not one for me. I went to the Processing subreddit\cite{RPROCESSING} to ask getting started questions and decided that this group would be where I would start a weekly challenge to help me improve my skills, as well as the community. This was a direct inspiration for my project in that it made me more confident in my Processing ability, but also made me want to help others in the Digital Art community learn Processing and my project is a realization of this.

\section{SAKBOT}
Early on in the project I was introduced to the SAKBOT architecture \cite{SAKBOT}, which uses Image Processing to isolate MVOs(Moving Visual Objects) in a scene. It uses advanced techniques such as Optical Flow and Blob Detection in order to separately Classify the following:
\begin{enumerate}
  \item MVO: Moving Visual objects that we are interested in, for example if we were looking to detect cars in a scene then the MVO would be the car itself.
  \item Ghost: A Ghost is a "change" in a scene which does not represent the location of an MVO. For example the reflection of the car in a nearby shop window would be considered a Ghost as although there is a clear change, it is not an MVO that we would be interested in.
  \item MVO-shadows: A Moving Visual Object shadow is a shadow which is connected to a Moving visual object, a shadow can simply be identified as a change in Brightness without a change in color.
  \item Ghost-shadows: A Ghost shadow is any shadow not connected to a moving visual object, over time shadows in a scene may move due to the sun changing position, we do not want to count these as a "change".
\end{enumerate}


\chapter{Change Detection Basics}
In this section I will discuss the fundamentals of change detection and move up onto more complex techniques used to increase accuracy. Change Detection is the process of finding the changes in a scene over any period of time, in this case we will use live video as this leads to better interaction.

\section{Thresholding}
Thresholding is a very trivial method of segmenting any image into two parts. It involves selecting a value and assigning any pixel value below that value to one segment, and any pixel equal or above that value is assigned to the other segment.

One issue with thresholding is you need to choose a threshold value to compare each pixel with. One method for doing this is finding the average value of all pixels and choosing this as you can expect about half of the pixels to be in each segment.

I chose a threshold value of 20 as this simply looked good in most well lit scenes, the user also has the ability to change this value in the default change detection algorithm.
\section{Euclidean Distance}
Euclidean distance is the distance between two points in a space. The trivial example here is in greyscale color given points $x$ and $y$ the euclidean distance between the two points is $\sqrt{(x-y)^2}$. This trivially extends as more color channels or different color spaces are added. We can use this to trivially decide what is considered a large enough "change" in a pixel. While I started with this method for RGB color I quickly moved away as this would consider shadows to be a change and changing the lighting in the room would also register as a change.

\section{Color Normalization}
Color Normalization is a good way to ignore changes in brightness in RGB color space. if a shadow is cast over a white object although we would register a change because white and black are different colors, however we don't want to consider shadows to be a change, or even slight changes in scene lighting could register changes. Given $L_R,L_G,L_B$ are respectively the red, green and blue color channels and we have some $\theta$ as our comparison value then $\frac{L_R + L_G}{L_R + L_G + L_B}$ should give us a value to compare with $\theta$ which is no longer dependent on the brightness of the change and only the hue and saturation. This means that pure white and pure black are not considered a change from one another.

\section{HSB Color Space}
The HSB color space is a different way of representing colors, I started using RGB, which has a separate channel for Red,Green and Blue colors. I moved to HSB (Hue,Saturation,Brightness) as then I do not have to worry about using color normalization as discussed in the previous section so this became the natural progression of my work. Ignoring changes in brightness when performing euclidean distance on any two points means that shadows will be ignored successfully solving one of the problems of trivial change detection.
\section{Problems with Basic Change Detection}
\subsection{Brightness Changes}
\subsection{Noise}
\subsection{Background}
\subsection{Shadows}

\chapter{Change Detection Advanced}
\section{OpenCV}
\subsection{Built in diff}
\subsection{Built in background subtraction}
\subsection{Erosion}
\subsection{Dilation}
\subsection{Optical Flow}
\subsection{Blob Detection}

\chapter{Building an Artistic Product}
\section{Requirements Elicitation}
\subsection{Types of Interview}
\subsection{decision and justification}
\section{Codification}
\section{Requirements}

\chapter{Functionality}
\section{Camera}
\section{Color}
\section{Image}
\section{Video}
\section{Code}

\chapter{Usability}
\section{Read Me}
\section{Tutorials}

\chapter{Evaluation}
\section{Expectations}
\section{Evolution of project}
\section{What I have learned}


\bibliographystyle{alpha}
\bibliography{sample}

\end{document}